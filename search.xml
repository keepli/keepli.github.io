<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker安装和配置镜像加速</title>
    <url>/2020/01/24/Docker%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F/</url>
    <content><![CDATA[<p><em>Docker 是一个开源的应用容器引擎，诞生于 2013 年初，基于 Go 语言实现， dotCloud 公司出品（后改名为Docker Inc） Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上</em></p>
<a id="more"></a>

<h3 id="一、安装Docker"><a href="#一、安装Docker" class="headerlink" title="一、安装Docker"></a>一、安装Docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、yum 包更新到最新 </span></span><br><span class="line">yum update</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 </span></span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、 设置yum源</span></span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、 安装docker，出现输入的界面都按 y </span></span><br><span class="line">yum install -y docker-ce</span><br><span class="line"><span class="meta">#</span><span class="bash"> 5、 查看docker版本，验证是否验证成功</span></span><br><span class="line">docker -v</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二、配置镜像加速"><a href="#二、配置镜像加速" class="headerlink" title="二、配置镜像加速"></a>二、配置镜像加速</h3><p>因为docker下载镜像时默认都是通过外网下载，速度慢的要死，所以自己还是要配置国内镜像地址</p>
<p><strong>我使用的是阿里云镜像加速，在阿里云控制台找到容器镜像服务中的镜像加速器，可以看到自己的加速地址与操作步骤</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20201006150308592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpc2h1d2VuNzk4Ng==,size_16,color_FFFFFF,t_70#pic_center"></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile常用关键字</title>
    <url>/2020/01/27/Dockerfile%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p> <em>Dockerfile常用关键字和作用</em></p>
<a id="more"></a>

<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><table>
<thead>
<tr>
<th>关键字</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>指定父镜像</td>
<td>指定dockerfile基于那个image构建</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>作者信息</td>
<td>用来标明这个dockerfile谁写的</td>
</tr>
<tr>
<td>LABEL</td>
<td>标签</td>
<td>用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在docker image基本信息中可以查看</td>
</tr>
<tr>
<td>RUN</td>
<td>执行命令</td>
<td>执行一段命令 默认是/bin/sh 格式: RUN command 或者 RUN [“command” , “param1”,”param2”]</td>
</tr>
<tr>
<td>CMD</td>
<td>容器启动命令</td>
<td>提供启动容器时候的默认命令 和ENTRYPOINT配合使用.格式 CMD command param1 param2 或者 CMD [“command” , “param1”,”param2”]</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>入口</td>
<td>一般在制作一些执行就关闭的容器中会使用</td>
</tr>
<tr>
<td>COPY</td>
<td>复制文件</td>
<td>build的时候复制文件到image中</td>
</tr>
<tr>
<td>ADD</td>
<td>添加文件</td>
<td>build的时候添加文件到image中 不仅仅局限于当前build上下文 可以来源于远程服务</td>
</tr>
<tr>
<td>ENV</td>
<td>环境变量</td>
<td>指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式ENV name=value</td>
</tr>
<tr>
<td>ARG</td>
<td>构建参数</td>
<td>构建参数 只在构建的时候使用的参数 如果有ENV 那么ENV的相同名字的值始终覆盖arg的参数</td>
</tr>
<tr>
<td>VOLUME</td>
<td>定义外部可以挂载的数据卷</td>
<td>指定build的image那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME [“目录”]</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>暴露端口</td>
<td>定义容器运行的时候监听的端口 启动容器的使用-p来绑定暴露端口 格式: EXPOSE 8080 或者 EXPOSE 8080/udp</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>工作目录</td>
<td>指定容器内部的工作目录 如果没有创建则自动创建 如果指定/ 使用的是绝对地址 如果不是/开头那么是在上一条workdir的路径的相对路径</td>
</tr>
<tr>
<td>USER</td>
<td>指定执行用户</td>
<td>指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候的用户</td>
</tr>
<tr>
<td>HEALTHCHECK</td>
<td>健康检查</td>
<td>指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本身有健康监测机制</td>
</tr>
<tr>
<td>ONBUILD</td>
<td>触发器</td>
<td>当存在ONBUILD关键字的镜像作为基础镜像的时候 当执行FROM完成之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大</td>
</tr>
<tr>
<td>STOPSIGNAL</td>
<td>发送信号量到宿主机</td>
<td>该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。</td>
</tr>
<tr>
<td>SHELL</td>
<td>指定执行脚本的shell</td>
<td>指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker常用命令</title>
    <url>/2020/01/26/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p> <em>完全满足日常使用</em></p>
<a id="more"></a>

<h3 id="进程相关："><a href="#进程相关：" class="headerlink" title="进程相关："></a><font color=red>进程相关：</font></h3><h4 id="1-启动docker服务"><a href="#1-启动docker服务" class="headerlink" title="1. 启动docker服务"></a>1. 启动docker服务</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<h4 id="2-停止docker服务"><a href="#2-停止docker服务" class="headerlink" title="2. 停止docker服务"></a>2. 停止docker服务</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>

<h4 id="3-重启docker服务"><a href="#3-重启docker服务" class="headerlink" title="3. 重启docker服务"></a>3. 重启docker服务</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h4 id="4-查看docker运行状态"><a href="#4-查看docker运行状态" class="headerlink" title="4. 查看docker运行状态"></a>4. 查看docker运行状态</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>

<h4 id="5-设置docker开机自启"><a href="#5-设置docker开机自启" class="headerlink" title="5. 设置docker开机自启"></a>5. 设置docker开机自启</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>
<h3 id="镜像相关："><a href="#镜像相关：" class="headerlink" title="镜像相关："></a><font color=red>镜像相关：</font></h3><h4 id="1-查看镜像："><a href="#1-查看镜像：" class="headerlink" title="1. 查看镜像："></a>1. 查看镜像：</h4><ul>
<li>查看本地所有镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line">docker images -q   # 查看所用镜像的id</span><br></pre></td></tr></table></figure>

<h4 id="2-搜索镜像："><a href="#2-搜索镜像：" class="headerlink" title="2. 搜索镜像："></a>2. 搜索镜像：</h4><ul>
<li>从网络中查找需要的镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search 镜像名称</span><br></pre></td></tr></table></figure>

<h4 id="3-拉取镜像："><a href="#3-拉取镜像：" class="headerlink" title="3. 拉取镜像："></a>3. 拉取镜像：</h4><ul>
<li>从Docker仓库下载镜像到本地，镜像名称格式为名称:版本号，如果版本号不指定则是最新的版本。<br>如果不知道镜像版本，可以去docker hub搜索对应镜像查看。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull 镜像名称</span><br><span class="line">docker pull 镜像名称:版本号</span><br></pre></td></tr></table></figure>

<h4 id="4-删除镜像："><a href="#4-删除镜像：" class="headerlink" title="4. 删除镜像："></a>4. 删除镜像：</h4><ul>
<li>删除本地镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi 镜像id   # 通过id删除本地镜像</span><br><span class="line">docker rmi 镜像名称:版本号 # 通过名称加版本号删除本地镜像</span><br><span class="line">docker rmi docker images -q   # 删除所有本地镜像</span><br></pre></td></tr></table></figure>
<h3 id="容器相关："><a href="#容器相关：" class="headerlink" title="容器相关："></a><font color=red>容器相关：</font></h3><h4 id="1-创建容器："><a href="#1-创建容器：" class="headerlink" title="1. 创建容器："></a>1. 创建容器：</h4><ul>
<li>-i: 允许你对容器内的标准输入 (STDIN) 进行交互<br>（保持容器一直运行着，否则在没有客户端连接时可能会自动关闭）</li>
<li>-t: 在新容器内指定一个伪终端或终端</li>
<li>-d：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用docker exec 进入容器。退出后，容器不会关闭</li>
<li>-p：映射端口</li>
<li>-it 创建的容器一般称为交互式容器，-id 创建的容器一般称为守护式容器</li>
<li>–name：为创建的容器命名</li>
<li>如果要运行的镜像如果不存在，则自动会进行下载</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --name=自定义容器名称 镜像名称:版本号 /bin/bash </span><br><span class="line"><span class="meta">#</span><span class="bash">示例：docker run -it --name=c1 centos:7 /bin/bash</span></span><br><span class="line"></span><br><span class="line">docker run -id --name=命名 镜像名称:版本号 /bin/bash </span><br><span class="line"><span class="meta">#</span><span class="bash">后台创建容器，创建之后不会自己进入容器，并且在执行<span class="built_in">exit</span>之后容器也不会退出</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -id -p 宿主机端口:容器端口 --name=自定义容器名称 镜像名称:版本号 /bin/bash </span><br><span class="line"><span class="meta">#</span><span class="bash"> 端口映射创建容器</span></span><br></pre></td></tr></table></figure>


<h4 id="2-进入容器："><a href="#2-进入容器：" class="headerlink" title="2. 进入容器："></a>2. 进入容器：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器名称 /bin/bash #  退出容器，容器不会关闭</span><br></pre></td></tr></table></figure>
<h4 id="3-退出容器："><a href="#3-退出容器：" class="headerlink" title="3. 退出容器："></a>3. 退出容器：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<h4 id="4-停止容器："><a href="#4-停止容器：" class="headerlink" title="4. 停止容器："></a>4. 停止容器：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop 容器名称</span><br></pre></td></tr></table></figure>

<h4 id="5-启动容器："><a href="#5-启动容器：" class="headerlink" title="5. 启动容器："></a>5. 启动容器：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start 容器名称</span><br></pre></td></tr></table></figure>

<h4 id="6-删除容器："><a href="#6-删除容器：" class="headerlink" title="6. 删除容器："></a>6. 删除容器：</h4><ul>
<li>如果容器是运行状态则删除失败，需要停止容器才能删除</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shelldocker rm 容器名称</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm `docker ps -aq`  # 删除所有容器</span><br></pre></td></tr></table></figure>


<h4 id="7-查看容器信息："><a href="#7-查看容器信息：" class="headerlink" title="7. 查看容器信息："></a>7. 查看容器信息：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect 容器名称</span><br></pre></td></tr></table></figure>
<h4 id="8-查看运行的容器："><a href="#8-查看运行的容器：" class="headerlink" title="8. 查看运行的容器："></a>8. 查看运行的容器：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker ps -a #查看历史运行过的容器</span><br></pre></td></tr></table></figure>
<h3 id="数据卷相关："><a href="#数据卷相关：" class="headerlink" title="数据卷相关："></a><font color=red>数据卷相关：</font></h3><h4 id="1-配置数据卷："><a href="#1-配置数据卷：" class="headerlink" title="1. 配置数据卷："></a>1. 配置数据卷：</h4><ul>
<li>目录必须是绝对路径</li>
<li>如果目录不存在，会自动创建</li>
<li>一个容器可以挂载多个数据卷</li>
<li>一个数据卷也可以被多个容器所挂载</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run ... –v 宿主机目录(文件):容器内目录(文件) ... </span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例：docker run -id --name=c1 -v /root/data:/root/data centos:7 /bin/bash</span></span><br><span class="line">docker run -it --name=c2 -v /root/data2:/root/data2 -v /root/data3:/root/data3 centos:7 /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 一个容器上可以挂载多个数据卷</span></span><br></pre></td></tr></table></figure>

<h4 id="2-配置数据卷容器："><a href="#2-配置数据卷容器：" class="headerlink" title="2. 配置数据卷容器："></a>2. 配置数据卷容器：</h4><pre class="mermaid">graph LR;
c1容器-->c3数据卷容器;
c2容器-->c3数据卷容器;
c3数据卷容器-->数据卷;</pre>

<ul>
<li>由于没有指定宿主机的目录，所以会自动创建一个目录做为数据卷，/volume是容器的数据卷（可以自定义命名）</li>
<li>通过查看容器信息的命令知道宿主机的数据卷位置</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run –it --name=c3 –v /volume centos:7 /bin/bash </span><br><span class="line"><span class="meta">#</span><span class="bash">创建启动c3数据卷容器，使用 –v 参数 设置数据卷</span></span><br></pre></td></tr></table></figure>
<ul>
<li>c1、c2容器的数据卷来源c3数据卷容器，就算c3容器挂了，数据卷也可以正常使用</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run –it --name=c1 --volumes-from c3 centos:7 /bin/bash</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run –it --name=c2 --volumes-from c3 centos:7 /bin/bash  </span><br><span class="line"><span class="meta">#</span><span class="bash">创建启动 c1 c2 容器，使用 –-volumes-from 参数 设置数据卷</span></span><br></pre></td></tr></table></figure>

<h3 id="制作自己的镜像文件："><a href="#制作自己的镜像文件：" class="headerlink" title="制作自己的镜像文件："></a><font color=red>制作自己的镜像文件：</font></h3><h4 id="1-普通制作镜像的方法（了解）："><a href="#1-普通制作镜像的方法（了解）：" class="headerlink" title="1. 普通制作镜像的方法（了解）："></a>1. 普通制作镜像的方法（了解）：</h4><pre class="mermaid">graph LR
制作镜像/只能自己使用-->压缩镜像/可以进行传输
压缩镜像/可以进行传输-->还原镜像/解压文件并还原</pre>

<ul>
<li><h5 id="1-制作镜像"><a href="#1-制作镜像" class="headerlink" title="1. 制作镜像"></a>1. 制作镜像</h5></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit 容器id 镜像名称:版本号</span><br></pre></td></tr></table></figure>

<ul>
<li><h5 id="2-压缩镜像"><a href="#2-压缩镜像" class="headerlink" title="2. 压缩镜像"></a>2. 压缩镜像</h5></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker save -o 压缩文件名称.tar 镜像名称:版本号</span><br></pre></td></tr></table></figure>

<ul>
<li><h5 id="3-还原镜像"><a href="#3-还原镜像" class="headerlink" title="3. 还原镜像"></a>3. 还原镜像</h5></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker load –i 压缩文件名称</span><br></pre></td></tr></table></figure>
<h4 id="2-使用Dockerfile制作镜像"><a href="#2-使用Dockerfile制作镜像" class="headerlink" title="2. 使用Dockerfile制作镜像"></a>2. 使用Dockerfile制作镜像</h4><pre class="mermaid">graph LR
创建dockerfile文件-->通过dockerfile文件创建镜像
通过dockerfile文件创建镜像-->创建容器进行使用</pre>
<ul>
<li><h5 id="1-通过dockerfile文件创建镜像"><a href="#1-通过dockerfile文件创建镜像" class="headerlink" title="1.通过dockerfile文件创建镜像"></a>1.通过dockerfile文件创建镜像</h5></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -f dockerfile文件名 -t 要构建镜像的名称 版本号 .</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意：.一定要加，并且前面有空格，用来指定路径的</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO中如何支持mermaid图表</title>
    <url>/2020/03/15/HEXO%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81mermaid%E5%9B%BE%E8%A1%A8/</url>
    <content><![CDATA[<p> <em>使用mermaid图表的人都说好，但是hexo不支持，以下是我亲自试用开启hexo对mermaid图表支持，大家可以放心、安全、无毒使用！！！</em></p>
<a id="more"></a>

<h4 id="一、首先想要HEXO支持-mermaid-图表需要安装一个插件："><a href="#一、首先想要HEXO支持-mermaid-图表需要安装一个插件：" class="headerlink" title="一、首先想要HEXO支持 mermaid 图表需要安装一个插件："></a>一、首先想要HEXO支持 mermaid 图表需要安装一个插件：</h4><ul>
<li>执行npm命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-filter-mermaid-diagrams</span><br></pre></td></tr></table></figure>
<h4 id="二、-编辑-config-yml-配置文件"><a href="#二、-编辑-config-yml-配置文件" class="headerlink" title="二、 编辑_config.yml 配置文件"></a>二、 编辑<em>_config.yml</em> 配置文件</h4><ul>
<li>在 <em>_config.yml</em>配置文件中<font color=red>（根目录下的 ）</font>的最后加上以下内容 </li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mermaid chart</span></span><br><span class="line"><span class="attr">mermaid:</span> <span class="comment">## mermaid url https://github.com/knsv/mermaid</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># default true</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">&quot;7.1.2&quot;</span> <span class="comment"># default v7.1.2</span></span><br><span class="line">  <span class="attr">options:</span>  <span class="comment"># find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js</span></span><br><span class="line">    <span class="comment">#startOnload: true  // default true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>需要注意的是检查<font color=red>主题中</font>的<em>_config.yml</em>配置文件是否有mermaid的配置<font color=red>（next主题）</font></li>
<li>如果有的话默认是一下配置，需要把enable改为<code>true</code>，否则插件不会被启用</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Mermaid tag</span></span><br><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> </span><br><span class="line">  <span class="comment"># Available themes: default | dark | forest | neutral</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">forest</span></span><br></pre></td></tr></table></figure>

<h4 id="三、-引入相关的js文件"><a href="#三、-引入相关的js文件" class="headerlink" title="三、 引入相关的js文件"></a>三、 引入相关的js文件</h4><ul>
<li>找到主题里面的页脚文件， <code>themes/next/layout/_partials/footer.swig</code> ，在文件最末尾加入以下内容 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if (theme.mermaid.enable)  %&#125;</span><br><span class="line">  &lt;script src&#x3D;&#39;https:&#x2F;&#x2F;unpkg.com&#x2F;mermaid@&#123;&#123; theme.mermaid.version &#125;&#125;&#x2F;dist&#x2F;mermaid.min.js&#39;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    if (window.mermaid) &#123;</span><br><span class="line">      mermaid.initialize(&#123;theme: &#39;forest&#39;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、配置完成之后执行三部曲："><a href="#四、配置完成之后执行三部曲：" class="headerlink" title="四、配置完成之后执行三部曲："></a>四、配置完成之后执行三部曲：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean # 清理</span><br><span class="line">hexo g	   # 构建</span><br><span class="line">hexo s     # 运行</span><br></pre></td></tr></table></figure>



<h4 id="五、最后献上几个链接供参考："><a href="#五、最后献上几个链接供参考：" class="headerlink" title="五、最后献上几个链接供参考："></a>五、最后献上几个链接供参考：</h4><p><code>官网：</code></p>
<blockquote>
<p> <a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams">https://github.com/webappdevelp/hexo-filter-mermaid-diagrams </a></p>
</blockquote>
<p><code>参考文献:</code></p>
<blockquote>
<p><a href="https://tyloafer.github.io/posts/7790/">https://tyloafer.github.io/posts/7790/  </a></p>
<p><a href="https://rogersnowing.cn/post/38b5106c.html">https://rogersnowing.cn/post/38b5106c.html </a></p>
</blockquote>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>live2d看板娘带回家</title>
    <url>/2020/04/10/live2d%E7%9C%8B%E6%9D%BF%E5%A8%98%E5%B8%A6%E5%9B%9E%E5%AE%B6/</url>
    <content><![CDATA[<p> <em>萌萌的看板娘不仅B格上来了，还能在你遨游知识的海洋时进行互动，可萌可看家，还等什么，动手吧~</em></p>
<a id="more"></a>

<h3 id="一、简单模式"><a href="#一、简单模式" class="headerlink" title="一、简单模式"></a><font color=red>一、简单模式</font></h3><h4 id="1-安装hexo-helper-live2d插件"><a href="#1-安装hexo-helper-live2d插件" class="headerlink" title="1. 安装hexo-helper-live2d插件"></a>1. 安装hexo-helper-live2d插件</h4><ul>
<li>如果之前安装过先卸载掉</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-helper-live2d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查博客主目录下面的 package.json里是否有<span class="string">&quot;hexo-helper-live2d&quot;</span>: <span class="string">&quot;^3.0.3&quot;</span> 依赖</span></span><br></pre></td></tr></table></figure>
<ul>
<li>没有则执行安装命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure>

<p> <strong>注意：</strong> <font color=red>命令都是在博客主目录执行 </font></p>
<h4 id="2-安装之后-node-moduels目录下，可以看到有live2d-widget文件夹，这些都是动画主配置"><a href="#2-安装之后-node-moduels目录下，可以看到有live2d-widget文件夹，这些都是动画主配置" class="headerlink" title="2.  安装之后 node_moduels目录下，可以看到有live2d-widget文件夹，这些都是动画主配置"></a>2.  安装之后 <code>node_moduels</code>目录下，可以看到有<code>live2d-widget</code>文件夹，这些都是动画主配置</h4><ul>
<li>到github中下载各种动画model </li>
</ul>
<p><a href="https://github.com/xiazeyu/live2d-widget-models.git"> https://github.com/xiazeyu/live2d-widget-models.git </a></p>
<h4 id="3-下载好之后将packages里的所有动画模板拷贝到博客的node-modules目录里"><a href="#3-下载好之后将packages里的所有动画模板拷贝到博客的node-modules目录里" class="headerlink" title="3. 下载好之后将packages里的所有动画模板拷贝到博客的node_modules目录里"></a>3. 下载好之后将packages里的所有动画模板拷贝到博客的node_modules目录里</h4><ul>
<li>注意：拷出的文件跟<code>live2d-widget</code>文件夹平级</li>
</ul>
<h4 id="4-把下面的配置复制到博客站点配置文件-config-yml-最下面"><a href="#4-把下面的配置复制到博客站点配置文件-config-yml-最下面" class="headerlink" title="4.  把下面的配置复制到博客站点配置文件_config.yml 最下面"></a>4.  把下面的配置复制到博客站点配置文件<code>_config.yml </code>最下面</h4><ul>
<li>模板效果参考链接：<a href="https://blog.csdn.net/wang_123_zy/article/details/87181892"> https://blog.csdn.net/wang_123_zy/article/details/87181892 </a></li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-epsilon2_1</span>  <span class="comment">#模板目录，在node_modules里</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">150</span> </span><br><span class="line">    <span class="attr">height:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">false</span>  <span class="comment">#是否在手机进行显示</span></span><br></pre></td></tr></table></figure>

<h4 id="5-配置完成之后执行三部曲就OK了："><a href="#5-配置完成之后执行三部曲就OK了：" class="headerlink" title="5. 配置完成之后执行三部曲就OK了："></a>5. 配置完成之后执行三部曲就OK了：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean # 清理</span><br><span class="line">hexo g	   # 构建</span><br><span class="line">hexo s     # 运行</span><br></pre></td></tr></table></figure>

<h3 id="二、困难模式"><a href="#二、困难模式" class="headerlink" title="二、困难模式"></a><font color=red>二、困难模式</font></h3><h4 id="1-把之前的live2d卸载掉-npm-uninstall-hexo-helper-live2d"><a href="#1-把之前的live2d卸载掉-npm-uninstall-hexo-helper-live2d" class="headerlink" title="1.  把之前的live2d卸载掉 npm uninstall hexo-helper-live2d"></a>1.  把之前的live2d卸载掉 <code>npm uninstall hexo-helper-live2d</code></h4><h4 id="2-下载配置-戳这里"><a href="#2-下载配置-戳这里" class="headerlink" title="2. 下载配置 戳这里"></a>2. 下载配置 <font color=blue><a href="https://github.com/stevenjoezhang/live2d-widget">戳这里</a></font></h4><h4 id="3-下载好后目录为live2d-widget-拷贝到主目录-themes-next-source目录下"><a href="#3-下载好后目录为live2d-widget-拷贝到主目录-themes-next-source目录下" class="headerlink" title="3. 下载好后目录为live2d-widget ,拷贝到主目录\themes\next\source目录下"></a>3. 下载好后目录为live2d-widget ,拷贝到主目录\themes\next\source目录下</h4><h4 id="4-然后修改autoload-js文件，将路径改为绝对路径"><a href="#4-然后修改autoload-js文件，将路径改为绝对路径" class="headerlink" title="4.  然后修改autoload.js文件，将路径改为绝对路径"></a>4.  然后修改autoload.js文件，将路径改为绝对路径</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：live2d_path 参数应使用绝对路径</span></span><br><span class="line"><span class="comment">//const live2d_path = &quot;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/&quot;;</span></span><br><span class="line"><span class="keyword">const</span> live2d_path = <span class="string">&quot;/live2d-widget/&quot;</span>; <span class="comment">//把这里注释解开，上面的路径注释掉就行了</span></span><br></pre></td></tr></table></figure>

<h4 id="5-引入链接-，修改-layout-swing文件（复制到head标签中）"><a href="#5-引入链接-，修改-layout-swing文件（复制到head标签中）" class="headerlink" title="5.  引入链接 ，修改_layout.swing文件（复制到head标签中）"></a>5.  引入链接 ，修改<code>_layout.swing</code>文件<font color=red>（复制到head标签中）</font></h4><ul>
<li>有一些主题,路径在<code>/themes/主题名字/layout/_partial/head.ejs</code>目录下 </li>
<li>我自己使用的next主题,是在<code>/themes/next/layout/_layout.swing</code>目录下 </li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/live2d-widget/autoload.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>添加之后如下：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  &#123;&#123; partial(&#x27;_partials/head/head.swig&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;</span><br><span class="line">  &#123;% include &#x27;_partials/head/head-unique.swig&#x27; %&#125;</span><br><span class="line">  &#123;&#123;- next_inject(&#x27;head&#x27;) &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;% block title %&#125;&#123;% endblock %&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  &#123;&#123; partial(&#x27;_third-party/analytics/index.swig&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;</span><br><span class="line">  &#123;&#123; partial(&#x27;_scripts/noscript.swig&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/live2d-widget/autoload.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>想修改看板娘大小、位置、格式、文本内容等，可查看并修改 <code>waifu-tips.js</code> 、 <code>waifu-tips.json</code> 、<code>waifu.css</code>文件</strong></p>
<p><a href=https://www.chensheng.group/2020/07/27/135-hexo%E7%9C%8B%E6%9D%BF%E5%A8%98/><font color=pink>链接参考</font></a></p>
]]></content>
      <categories>
        <category>live2d看板娘</category>
      </categories>
      <tags>
        <tag>live2d</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务架构</title>
    <url>/2020/05/10/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p><em>微服务架构与SOA架构</em></p>
<a id="more"></a><meta name="referrer" content="no-referrer"/> 

<h3 id="一、系统架构演变概述"><a href="#一、系统架构演变概述" class="headerlink" title="一、系统架构演变概述"></a><font color=red>一、系统架构演变概述</font></h3><h4 id="1-了解项目架构的演变历程"><a href="#1-了解项目架构的演变历程" class="headerlink" title="1. 了解项目架构的演变历程"></a>1. 了解项目架构的演变历程</h4><pre class="mermaid">graph LR;
1[集中式架构] --> 2[垂直拆分]
2 --> 3[分布式服务]
3 --> 4[SOA面向服务架构]
4 --> 5[微服务架构]</pre>

<h3 id="二、-微服务架构说明"><a href="#二、-微服务架构说明" class="headerlink" title="二、 微服务架构说明"></a><font color=red>二、 微服务架构说明</font></h3><h4 id="1-微服务架构"><a href="#1-微服务架构" class="headerlink" title="1. 微服务架构"></a>1. 微服务架构</h4><ul>
<li>是一套使用小服务或者单一业务来开发单个应用的方式或途径</li>
<li>每个服务基于单一业务能力构建，运行在自己的进程中，并使用轻量级机制通信，通常是HTTP API，并能够通过自动化部署机制来独立部署</li>
<li>这些服务可以使用不同的编程语言实现，以及不同数据存储技术，并保持最低限度的集中式管理</li>
</ul>
<h4 id="2-微服务架构特点"><a href="#2-微服务架构特点" class="headerlink" title="2. 微服务架构特点"></a>2. 微服务架构特点</h4><ul>
<li>单一职责</li>
<li>服务粒度小</li>
<li>面向服务（对外暴露REST api）</li>
<li>服务之间相互独立</li>
</ul>
<p>与使用ESB（<a href="https://baike.baidu.com/item/%E4%BC%81%E4%B8%9A%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BA%BF/8790284?fromtitle=ESB&fromid=8742700">企业服务总线</a>）的SOA架构的区别：微服务架构没有使用ESB，有服务治理注册中心；业务粒度小</p>
<h4 id="3-微服务经典架构图"><a href="#3-微服务经典架构图" class="headerlink" title="3. 微服务经典架构图"></a>3. 微服务经典架构图</h4><p><img src="https://img-blog.csdn.net/20180322093134220?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L0JhY3RyeWtpMjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
<p><img src="https://img-blog.csdnimg.cn/20191105101232477.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAxMzEyNzc=,size_16,color_FFFFFF,t_70" alt="springcloud"></p>
<h4 id="4-微服务架构与SAO架构的区别"><a href="#4-微服务架构与SAO架构的区别" class="headerlink" title="4. 微服务架构与SAO架构的区别"></a>4. 微服务架构与SAO架构的区别</h4><table>
<thead>
<tr>
<th>功能</th>
<th>SOA</th>
<th>微服务</th>
</tr>
</thead>
<tbody><tr>
<td>组件大小</td>
<td>大块业务逻辑</td>
<td>单独任务或小块业务逻辑</td>
</tr>
<tr>
<td>耦合</td>
<td>通常松耦合</td>
<td>总是松耦合</td>
</tr>
<tr>
<td>管理</td>
<td>看重中央管理</td>
<td>看重分散管理</td>
</tr>
<tr>
<td>目标</td>
<td>确保应用能够交互操作</td>
<td>易维护、易扩展、更轻量级的交互</td>
</tr>
</tbody></table>
<h4 id="5-服务调用方式"><a href="#5-服务调用方式" class="headerlink" title="5.服务调用方式"></a>5.服务调用方式</h4><ul>
<li><p>RPC：基于<a href="https://www.cnblogs.com/dolphinx/p/3460545.html">socket</a>，速度快，效率高；webservice、<code>dubbo</code></p>
</li>
<li><p>HTTP：基于TCP，封装比较臃肿；对服务和调用方没有任何技术、语言的限定，自由灵活；RESTful，<code>Spring Cloud</code></p>
</li>
</ul>
<h4 id="6-Http客户端工具"><a href="#6-Http客户端工具" class="headerlink" title="6. Http客户端工具"></a>6. Http客户端工具</h4><p>一般情况下有如下三种http客户端工具类包都可以方便的进行http服务调用：</p>
<ul>
<li>HttpClient</li>
<li>OKHttp</li>
<li>URLConnection</li>
</ul>
<p>spring 提供了RestTemplate的工具类对上述的3种http客户端工具类进行了封装，可在spring项目中使用RestTemplate进行服务调用</p>
<h3 id="三、SpringCloud"><a href="#三、SpringCloud" class="headerlink" title="三、SpringCloud"></a><font color=red>三、SpringCloud</font></h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p><code>官网：</code><a href="https://spring.io/projects/spring-cloud">点击此处跳转</a></p>
<p>Spring Cloud它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等功能；协调分布式环境中各个系统，为各类服务提供模板性配置。其主要涉及的组件包括：</p>
<ul>
<li>Eureka：注册中心</li>
<li>Zuul、Gateway：服务网关</li>
<li>Ribbon：负载均衡</li>
<li>Feign：服务调用</li>
<li>ConfigServer：配置中心</li>
<li>Hystrix或Resilience4j：熔断器</li>
</ul>
<p><strong>以上只是其中一部分，架构图如下：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200929093317233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpc2h1d2VuNzk4Ng==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p><img src="https://img-blog.csdnimg.cn/20190305125527818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxMDE0MDc0Nzk0,size_16,color_FFFFFF,t_70"></p>
<h4 id="2-版本说明"><a href="#2-版本说明" class="headerlink" title="2. 版本说明"></a>2. 版本说明</h4><p>Spring Cloud不是一个组件，而是许多组件的集合；它的版本命名比较特殊，是以A到Z的为首字母的一些单词（其实是伦敦地铁站的名字）组成</p>
]]></content>
      <categories>
        <category>微服务架构</category>
      </categories>
      <tags>
        <tag>微服务架构</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud组件</title>
    <url>/2020/05/13/springcloud%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p> <em>SpringCloud各组件的作用和使用</em></p>
<a id="more"></a>

<h2 id="一、服务注册中心Eureka"><a href="#一、服务注册中心Eureka" class="headerlink" title="一、服务注册中心Eureka"></a><font color=red>一、服务注册中心Eureka</font></h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><ul>
<li><p>Eureka就好比是滴滴，负责管理、记录服务提供者的信息。服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你</p>
</li>
<li><p>Eureka的主要功能是进行服务管理，定期检查服务状态，返回服务地址列表</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200929174342163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpc2h1d2VuNzk4Ng==,size_16,color_FFFFFF,t_70#pic_center"></p>
<ul>
<li>Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址</li>
<li>提供者：启动后向Eureka注册自己信息（地址，提供什么服务）</li>
<li>消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新</li>
<li>心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态</li>
</ul>
<h3 id="2-搭建eureka-server工程"><a href="#2-搭建eureka-server工程" class="headerlink" title="2. 搭建eureka-server工程"></a>2. 搭建eureka-server工程</h3><p><strong>目标</strong>：添加eureka对应依赖和编写引导类搭建eureka服务并可访问eureka服务界面</p>
<p><strong>分析</strong>：</p>
<p>Eureka是服务注册中心，只做服务注册；自身并不提供服务也不消费服务。搭建web工程使用Eureka，可以使用Spring Boot方式搭建。</p>
<p><strong>搭建步骤</strong>：</p>
<ol>
<li>创建工程</li>
<li>添加启动器依赖</li>
<li>编写启动引导类（添加Eureka的服务注解）和配置文件</li>
<li>修改配置文件（端口，应用名称…）</li>
<li>启动测试</li>
</ol>
<p><strong>小结</strong>：</p>
<ul>
<li>启动器依赖（父工程中已经指定了springcloud的版本号，所以这里不用指定版本号）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在springboot的启动类中添加@EnableEurekaServer注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span><span class="comment">//声明当前应用是Eureka服务</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<ul>
<li>配置文件</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="comment">#port: $&#123;port:10086&#125;</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># eureka 服务地址（虚拟的），如果是集群的话；需要指定其它集群eureka地址,后面加逗号隔开</span></span><br><span class="line">      <span class="comment">#defaultZone: $&#123;defaultZone:http://127.0.0.1:10086/eureka&#125;</span></span><br><span class="line">      <span class="comment">#例如：defaultZone: http://127.0.0.1:10086/eureka,http://0.0.0.0:10086/eureka</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br><span class="line">      <span class="comment"># 不注册自己，默认是true，如果是集群搭建需要注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">      <span class="comment"># 不拉取服务,默认是true，集群要为true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="comment">#服务失效剔除时间，默认60秒（以毫秒为单位）</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">3000</span></span><br><span class="line">    <span class="comment">#关闭自我保护模式（默认是打开的）</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="3-服务注册与发现"><a href="#3-服务注册与发现" class="headerlink" title="3.服务注册与发现"></a>3.服务注册与发现</h3><p><strong>目标</strong>：将user-service的服务注册到eureka并在consumer-demo中可以根据服务名称调用</p>
<p><strong>分析</strong>：</p>
<ul>
<li>服务注册：在服务提供工程user-service上添加Eureka客户端依赖；自动将服务注册到EurekaServer服务地址列表。<ul>
<li>添加依赖；</li>
<li>改造启动引导类；添加开启Eureka客户端发现的注解；</li>
<li>修改配置文件；设置Eureka 服务地址</li>
</ul>
</li>
<li>服务发现：在服务消费工程consumer-demo上添加Eureka客户端依赖；可以使用工具类根据服务名称获取对应的服务地址列表。<ul>
<li>添加依赖；</li>
<li>改造启动引导类；添加开启Eureka客户端发现的注解；</li>
<li>修改配置文件；设置Eureka 服务地址；</li>
<li>改造处理器类ConsumerController，可以使用工具类DiscoveryClient根据服务名称获取对应服务地址列表。</li>
</ul>
</li>
</ul>
<p><strong>小结</strong>：</p>
<ul>
<li>添加Eureka客户端依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>添加启动引导类注解<code>@EnableDiscoveryClient</code><font color=red>（消费端与生产端都要添加）</font></p>
<ul>
<li><strong>以下以生产端启动引导类示例</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span><span class="comment">//开启Eureka客户端发现功能</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;cn.itcast.user.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(UserApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改配置</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">consumer-demo</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在消费端的controller中获取生产端注册的url进行访问（后期一般配合负载均衡来获取，通过生产端的服务名就可获取到url）</li>
</ul>
<h3 id="4-高可用的Eureka-Server（集群搭建）"><a href="#4-高可用的Eureka-Server（集群搭建）" class="headerlink" title="4. 高可用的Eureka Server（集群搭建）"></a>4. 高可用的Eureka Server（集群搭建）</h3><ul>
<li><p>多个Eureka Server之间也会互相注册为服务，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现数据同步。因此，无论客户端访问到Eureka Server集群中的任意一个节点，都可以获取到完整的服务列表信息</p>
</li>
<li><p>如果有三个Eureka，则每一个EurekaServer都需要注册到其它几个Eureka服务中，例如：有三个分别为10086、10087、10088，则：</p>
<ul>
<li>10086要注册到10087和10088上</li>
<li>10087要注册到10086和10088上</li>
<li>10088要注册到10086和10087上</li>
</ul>
</li>
</ul>
<h3 id="5-Eureka客户端与服务端配置"><a href="#5-Eureka客户端与服务端配置" class="headerlink" title="5. Eureka客户端与服务端配置"></a>5. Eureka客户端与服务端配置</h3><p><strong>目标</strong>：配置eureka客户端user-service的注册、续约等配置项，配置eureka客户端consumer-demo的获取服务间隔时间，了解失效剔除和自我保护</p>
<p><strong>分析</strong>：</p>
<ul>
<li><a href="https://img-blog.csdnimg.cn/2020092923374064.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpc2h1d2VuNzk4Ng==,size_16,color_FFFFFF,t_70#pic_center">Eureka客户端工程</a><ul>
<li>user-service 服务提供<ul>
<li>服务地址使用ip方式</li>
<li>服务续约（心跳）</li>
</ul>
</li>
<li>consumer-demo 服务消费<ul>
<li>获取服务地址的频率</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://img-blog.csdnimg.cn/20200929233755362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpc2h1d2VuNzk4Ng==,size_16,color_FFFFFF,t_70#pic_center">Eureka服务端工程 eureka-server</a><ul>
<li>失效剔除</li>
<li>自我保护</li>
</ul>
</li>
</ul>
<p><strong>小结</strong>：</p>
<ul>
<li>user-service </li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 更倾向使用ip地址，而不是host名</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># ip地址</span></span><br><span class="line">    <span class="attr">ip-address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="comment"># 续约间隔，默认30秒</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">5</span></span><br><span class="line">    <span class="comment"># 服务失效时间，默认90秒</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<ul>
<li>consumer-demo </li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br><span class="line">    <span class="comment"># 获取服务地址列表间隔时间，默认30秒</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>eureka-server</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="comment"># 服务失效剔除时间间隔，默认60秒</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">60000</span></span><br><span class="line">    <span class="comment"># 关闭自我保护模式（默认是打开的）</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="二、负载均衡Ribbon"><a href="#二、负载均衡Ribbon" class="headerlink" title="二、负载均衡Ribbon"></a><font color=red>二、负载均衡Ribbon</font></h2><h3 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1. 简介"></a>1. 简介</h3><ul>
<li><p>负载均衡是一个算法，可以通过该算法实现从地址列表中获取一个地址进行服务调用，在Spring Cloud中提供了负载均衡器：Ribbon</p>
</li>
<li><p><strong>Eureka中已经集成了负载均衡组件：Ribbon</strong>，简单修改代码即可使用，不需要单独引入jar包</p>
</li>
</ul>
<p><strong>小结</strong>：</p>
<p>Ribbon提供了轮询、随机两种负载均衡算法（默认是轮询）可以实现从地址列表中使用负载均衡算法获取地址进行服务调用</p>
<h3 id="2-应用"><a href="#2-应用" class="headerlink" title="2. 应用"></a>2. 应用</h3><p><strong>目标</strong>：配置启动两个用户服务，在consumer-demo中使用服务名实现根据用户id获取用户</p>
<p><strong>分析</strong>：</p>
<p>需求：可以使用RestTemplate访问<a href="http://user-service/user/8%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E6%95%B0%E6%8D%AE">http://user-service/user/8获取服务数据</a><font color=red>（不需要拼字符串来获取了）</font></p>
<p>可以使用Ribbon负载均衡：在执行RestTemplate发送服务地址请求的时候，使用负载均衡拦截器拦截，根据服务名获取服务地址列表，使用Ribbon负载均衡算法从服务地址列表中选择一个服务地址，访问该地址获取服务数据。</p>
<p>实现步骤：</p>
<ol>
<li>启动多个user-service实例（9091,9092）；</li>
<li>修改RestTemplate实例化方法，添加负载均衡注解；</li>
<li>修改ConsumerController；</li>
<li>测试</li>
</ol>
<p><strong>小结</strong>：</p>
<ul>
<li>在<font color=red>实例化RestTemplate</font>的时候使用<code>@LoadBalanced</code>，服务地址直接可以使用服务名，并且按算法来分配</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@LoadBalanced</span><span class="comment">//开启负载均衡</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate (  );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不需要修改配置文件了，因为默认自动配置了<code>轮询方式</code>，如果要随机可以通过配置（了解）</li>
</ul>
<h2 id="三、熔断器Hystrix"><a href="#三、熔断器Hystrix" class="headerlink" title="三、熔断器Hystrix"></a><font color=red>三、熔断器Hystrix</font></h2><h3 id="1-简介-2"><a href="#1-简介-2" class="headerlink" title="1. 简介"></a>1. 简介</h3><ul>
<li><p>它在微服务系统中是一款提供保护机制的组件，和eureka一样也是由netflix公司开发</p>
</li>
<li><p>Hystrix是一个延迟和容错库，用于隔离访问远程服务，防止出现级联失败</p>
</li>
</ul>
<h3 id="2-线程隔离-amp-服务降级"><a href="#2-线程隔离-amp-服务降级" class="headerlink" title="2. 线程隔离&amp;服务降级"></a>2. 线程隔离&amp;服务降级</h3><p><a href="https://www.showdoc.com.cn/439784909434024?page_id=2827350358722234">Hystrix解决雪崩效应</a>：</p>
<ul>
<li>线程隔离：用户请求不直接访问服务，而是使用线程池中空闲的线程访问服务，加速失败判断时间</li>
<li>服务降级：及时返回服务调用失败的结果，让线程不因为等待服务而阻塞</li>
</ul>
<p><strong>小结</strong>：</p>
<ul>
<li>添加依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>开启熔断</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*@SpringBootApplication</span></span><br><span class="line"><span class="comment">@EnableDiscoveryClient //开启Eureka客户端发现功能</span></span><br><span class="line"><span class="comment">@EnableCircuitBreaker //开启熔断*/</span></span><br><span class="line"><span class="meta">@SpringCloudApplication</span> <span class="comment">//这个注解包含了上面三个注解</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span> <span class="comment">//开启Feign功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate (  );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>降级逻辑示例<font color=red>（要注意回调方法的返回类型要跟获取请求的方法的返回类型保持一致）</font></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/consumer&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@DefaultProperties(defaultFallback = &quot;defaultFallback&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="comment">//@HystrixCommand(fallbackMethod = &quot;queryByIdFallback&quot;)</span></span><br><span class="line">    <span class="meta">@HystrixCommand</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">queryById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span></span>&#123;</span><br><span class="line">        String url = <span class="string">&quot;http://user-service/user/&quot;</span> + id;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(url, String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">queryByIdFallback</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;查询用户信息失败。id：&#123;&#125;&quot;</span>, id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;对不起，网络太拥挤了！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">defaultFallback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;默认提示：对不起，网络太拥挤了！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改超时配置</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="comment">#配置Hystrix的超时时长为2秒，默认为1秒</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<h3 id="3-服务熔断演示"><a href="#3-服务熔断演示" class="headerlink" title="3. 服务熔断演示"></a>3. 服务熔断演示</h3><ul>
<li>熔断器工作原理</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200930220131513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpc2h1d2VuNzk4Ng==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p><strong>状态机有3个状态：</strong></p>
<ul>
<li>Closed：关闭状态（断路器关闭），所有请求都正常访问</li>
<li>Open：打开状态（断路器打开），所有请求都会被降级。Hystrix会对请求情况计数，当一定时间内失败请求百分比达到阈值，则触发熔断，断路器会完全打开。默认失败比例的阈值是50%，请求次数最少不低于20次</li>
<li>Half Open：半开状态，不是永久的，断路器打开后会进入休眠时间（默认是5S）。随后断路器会自动进入半开状态，此时会释放部分请求通过，若这些请求都是健康的，则会关闭断路器，否则继续保持打开，再次进行休眠计时</li>
</ul>
<p><strong>可以通过配置服务熔断参数修改默认：</strong><font color=red>（在开启了hystrix方配置）</font></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="comment">#配置Hystrix的超时时长为2秒，默认为1秒</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">1000</span></span><br><span class="line">      <span class="attr">circuitBreaker:</span></span><br><span class="line">        <span class="attr">errorThresholdPercentage:</span> <span class="number">50</span> <span class="comment"># 触发熔断错误比例阈值，默认值50%</span></span><br><span class="line">        <span class="attr">sleepWindowInMilliseconds:</span> <span class="number">10000</span> <span class="comment"># 熔断后休眠时长，默认值5秒</span></span><br><span class="line">        <span class="attr">requestVolumeThreshold:</span> <span class="number">10</span> <span class="comment"># 熔断触发最小请求次数，默认值是20</span></span><br></pre></td></tr></table></figure>

<h2 id="四、Feign应用"><a href="#四、Feign应用" class="headerlink" title="四、Feign应用"></a><font color=red>四、Feign应用</font></h2><h3 id="1-简介-3"><a href="#1-简介-3" class="headerlink" title="1. 简介"></a>1. 简介</h3><ul>
<li>Feign也叫伪装</li>
<li>Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做</li>
<li>我们只要写接口并且使用<code>@FeignClient</code>注解声明就行了，实现类自动为我们创建</li>
</ul>
<p><strong>目标</strong>：Feign的作用，使用Feign实现consumer-demo代码中调用服务</p>
<p><strong>分析</strong>：</p>
<ol>
<li>导入启动器依赖</li>
<li>开启Feign功能<code>@EnableFeignClients </code>（在启动类中添加）</li>
<li>编写Feign客户端<code>@FeignClient</code></li>
<li>编写一个处理器ConsumerFeignController，注入Feign客户端并使用</li>
<li>测试</li>
</ol>
<p><strong>小结</strong>：</p>
<p>Feign主要作用：自动根据参数拼接http请求地址</p>
<ul>
<li>启动器依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动类中开启Feign功能</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*@SpringBootApplication</span></span><br><span class="line"><span class="comment">@EnableDiscoveryClient //开启Eureka客户端发现功能</span></span><br><span class="line"><span class="comment">@EnableCircuitBreaker //开启熔断*/</span></span><br><span class="line"><span class="meta">@SpringCloudApplication</span> <span class="comment">//这个注解包含了上面三个注解</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span> <span class="comment">//开启Feign功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate (  );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Feign客户端<font color=red>（自动会我们创建一个实体类）</font></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明当前类是一个Feign客户端，指定服务名为user-service</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;user-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//http://user-service/user/123</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">queryById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用feign<font color=red>（feign中已经自动拼接了url，并且使用了负载均衡方式获取服务）</font></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Feign的处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/cf&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerFeignConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserClient userClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userClient.findById ( id );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问<a href="http://localhost:8080/cf/8%E8%B7%9F%E8%AE%BF%E9%97%AEhttp://localhost:8080/user-service/user/8%E4%B8%80%E6%A0%B7">http://localhost:8080/cf/8跟访问http://localhost:8080/user-service/user/8一样</a></p>
<h3 id="2-Feign负载均衡及熔断"><a href="#2-Feign负载均衡及熔断" class="headerlink" title="2.Feign负载均衡及熔断"></a>2.Feign负载均衡及熔断</h3><ul>
<li>Feign中已经自动集成了Ribbon负载均衡，因此不需要自己定义RestTemplate进行负载均衡的配置</li>
<li>Fegin还集成了Hystrix熔断器</li>
</ul>
<p><strong>目标</strong>：可以配置Feign内置ribbon配置项和Hystrix熔断的Fallback配置</p>
<p><strong>分析</strong>：</p>
<ul>
<li>负载均衡</li>
<li>服务熔断</li>
<li>请求压缩</li>
<li>日志级别</li>
</ul>
<p>都可以通过配置项在Feign中开启使用</p>
<p><strong>小结</strong>：</p>
<p>在服务消费工程consumer-demo中的配置文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">1000</span> <span class="comment"># 连接超时时长</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">2000</span> <span class="comment"># 数据通信超时时长</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">0</span> <span class="comment"># 当前服务器的重试次数</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">0</span> <span class="comment"># 重试多少次服务</span></span><br><span class="line">  <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">false</span> <span class="comment"># 是否对所有的请求方式都重试</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启Feign的熔断功能</span></span><br><span class="line">  <span class="attr">compression:</span></span><br><span class="line">    <span class="attr">request:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启请求压缩</span></span><br><span class="line">      <span class="attr">mime-types:</span> <span class="string">text/html,application/xml,application/json</span> <span class="comment"># 设置压缩的数据类型</span></span><br><span class="line">      <span class="attr">min-request-size:</span> <span class="number">2048</span> <span class="comment"># 设置触发压缩的大小下限</span></span><br><span class="line">    <span class="attr">response:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.itheima:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>

<h2 id="五、服务网关Gateway"><a href="#五、服务网关Gateway" class="headerlink" title="五、服务网关Gateway"></a><font color=red>五、服务网关Gateway</font></h2><h3 id="1-简介-4"><a href="#1-简介-4" class="headerlink" title="1.简介"></a>1.简介</h3><ul>
<li><p>核心就是一系列的过滤器，可以将客户端的请求转发到不同的微服务</p>
</li>
<li><p>本身也是一个微服务，需要注册到Eureka服务注册中心</p>
</li>
<li><p>主要作用：<strong>过滤、断言、路由</strong></p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201001004059122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpc2h1d2VuNzk4Ng==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h3 id="2-入门使用"><a href="#2-入门使用" class="headerlink" title="2.入门使用"></a>2.入门使用</h3><p><strong>目标</strong>：搭建网关服务工程测试网关服务作用</p>
<p><strong>分析</strong>：</p>
<p>需求：通过网关系统heima-gateway将包含有 /user 的请求 路由到 <a href="http://127.0.0.1:9091/user/%E7%94%A8%E6%88%B7id">http://127.0.0.1:9091/user/用户id</a> </p>
<p>实现步骤：</p>
<ol>
<li>创建工程；</li>
<li>添加启动器依赖；</li>
<li>编写启动引导类和配置文件；</li>
<li>修改配置文件，设置路由信息；</li>
<li>启动测试</li>
</ol>
<p><a href="http://127.0.0.1:10010/user/8">http://127.0.0.1:10010/user/8</a> –&gt; <a href="http://127.0.0.1:9091/user/8">http://127.0.0.1:9091/user/8</a></p>
<p><strong>小结</strong>：</p>
<ul>
<li>启动器依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>配置文件</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">api-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="comment"># 路由id，可以任意</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service-route</span></span><br><span class="line">          <span class="comment"># 代理的服务地址</span></span><br><span class="line">          <span class="comment">#uri: http://127.0.0.1:9091</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://user-service</span> <span class="comment">#lb是LoadBalance（负载均衡）的简写,负载均衡获取</span></span><br><span class="line">          <span class="comment"># 路由断言： 可以匹配映射路径</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="3-面向服务的路由"><a href="#3-面向服务的路由" class="headerlink" title="3. 面向服务的路由"></a>3. 面向服务的路由</h3><p>如果将路由服务地址写死明显是不合理的；在Spring Cloud Gateway中可以通过配置动态路由解决。</p>
<p><strong>小结</strong>：</p>
<p>面向服务的路由；只需要在配置文件中指定路由路径类似： <code>lb://user-service</code></p>
<blockquote>
<p>lb 之后编写的服务名必须要在eureka中注册才能使用</p>
</blockquote>
<h3 id="4-路由前缀处理"><a href="#4-路由前缀处理" class="headerlink" title="4. 路由前缀处理"></a>4. 路由前缀处理</h3><p><strong>目标</strong>：可以对请求到网关服务的地址添加或去除前缀</p>
<p><strong>分析</strong>：</p>
<p>提供服务的地址：<a href="http://127.0.0.1:9091/user/8">http://127.0.0.1:9091/user/8</a></p>
<ul>
<li>添加前缀：对请求地址添加前缀路径之后再作为代理的服务地址；</li>
</ul>
<p><a href="http://127.0.0.1:10010/8">http://127.0.0.1:10010/8</a> –&gt; <a href="http://127.0.0.1:9091/user/8">http://127.0.0.1:9091/user/8</a> 添加前缀路径/user</p>
<ul>
<li>去除前缀：将请求地址中路径去除一些前缀路径之后再作为代理的服务地址；</li>
</ul>
<p><a href="http://127.0.0.1:10010/api/user/8">http://127.0.0.1:10010/api/user/8</a> –&gt; <a href="http://127.0.0.1:9091/user/8">http://127.0.0.1:9091/user/8</a> 去除前缀路径/api</p>
<p><strong>小结</strong>：</p>
<p>客户端的请求地址与微服务的服务地址如果不一致的时候，可以通过配置路径过滤器实现路径前缀的添加和去除</p>
<h3 id="5-过滤器"><a href="#5-过滤器" class="headerlink" title="5.过滤器"></a>5.过滤器</h3><h4 id="1-类型和使用场景"><a href="#1-类型和使用场景" class="headerlink" title="1.类型和使用场景"></a>1.类型和使用场景</h4><ul>
<li><p>类型：局部、全局</p>
</li>
<li><p>使用场景：请求鉴权、异常处理、记录调用时长等</p>
</li>
</ul>
<h4 id="2-默认过滤器的用法"><a href="#2-默认过滤器的用法" class="headerlink" title="2.默认过滤器的用法"></a>2.默认过滤器的用法</h4><ul>
<li>用法：在配置文件中指定要使用的过滤器名称</li>
</ul>
<p>Gateway自带过滤器有几十个，常见自带过滤器有：</p>
<table>
<thead>
<tr>
<th>过滤器名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AddRequestHeader</td>
<td>对匹配上的请求加上Header</td>
</tr>
<tr>
<td>AddRequestParameters</td>
<td>对匹配上的请求路由添加参数</td>
</tr>
<tr>
<td>AddResponseHeader</td>
<td>对从网关返回的响应添加Header</td>
</tr>
<tr>
<td>StripPrefix</td>
<td>对匹配上的请求路径去除前缀</td>
</tr>
</tbody></table>
<p>更多过滤器和说明：<a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.1.RELEASE/single/spring-cloud-gateway.html#_gatewayfilter_factories">官网</a></p>
<h4 id="3-自定义局部过滤器"><a href="#3-自定义局部过滤器" class="headerlink" title="3.自定义局部过滤器"></a>3.自定义局部过滤器</h4><p><strong>目标</strong>：按照默认过滤器编写并配置一个自定义局部过滤器，该过滤器可以通过配置文件中的参数名称获取请求的参数值</p>
<p><strong>分析</strong>：</p>
<p>需求：在过滤器（MyParamGatewayFilterFactory）中将<a href="http://localhost:10010/api/user/8?name=itcast%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0name%E7%9A%84%E5%80%BC%E8%8E%B7%E5%8F%96%E5%88%B0%E5%B9%B6%E8%BE%93%E5%87%BA%E5%88%B0%E6%8E%A7%E5%88%B6%E5%8F%B0%EF%BC%9B%E5%B9%B6%E4%B8%94%E5%8F%82%E6%95%B0%E5%90%8D%E6%98%AF%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%AF%8F%E6%AC%A1%E9%83%BD%E6%98%AFname%EF%BC%9B%E9%9C%80%E8%A6%81%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%97%B6%E5%80%99%E5%81%9A%E5%88%B0%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E5%90%8D%E3%80%82">http://localhost:10010/api/user/8?name=itcast中的参数name的值获取到并输出到控制台；并且参数名是可变的，也就是不一定每次都是name；需要可以通过配置过滤器的时候做到配置参数名。</a></p>
<p>实现步骤：</p>
<ol>
<li>配置过滤器；</li>
<li>编写过滤器；</li>
<li>测试</li>
</ol>
<p><strong>小结</strong>：</p>
<ul>
<li>配置；与其他过滤器的配置一致</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-gateway</span></span><br><span class="line">  <span class="comment">#配置网关</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="comment">#id可以任意</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service-route</span></span><br><span class="line">        <span class="comment">#代理的服务地址</span></span><br><span class="line">          <span class="comment">#uri: http://127.0.0.1:9091</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://user-service</span> <span class="comment">#lb是LoadBalance（负载均衡）的简写</span></span><br><span class="line">          </span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">MyParam=name</span> <span class="comment">#自定义的局部过滤器</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实现过滤器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//需要交给spring来管理，否则过滤器无效</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyParamGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title">AbstractGatewayFilterFactory</span>&lt;<span class="title">MyParamGatewayFilterFactory</span>.<span class="title">NameValueConfig</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyParamGatewayFilterFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>( MyParamGatewayFilterFactory.NameValueConfig.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NameValueConfig</span></span>&#123;</span><br><span class="line">        <span class="comment">//对应在配置过滤器的时候指定的参数名</span></span><br><span class="line">        <span class="keyword">private</span> String param;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getParam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> param;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParam</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.param = param;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">shortcutFieldOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//param要跟静态内部类的成员变量名一样</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="string">&quot;param&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GatewayFilter <span class="title">apply</span><span class="params">(NameValueConfig config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GatewayFilter ( ) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// http://localhost:10010/api/user/8?name=itcast   config.param ==&gt; name</span></span><br><span class="line">                <span class="comment">//获取请求参数中param对应的参数名的值</span></span><br><span class="line">                ServerHttpRequest request = exchange.getRequest ( );</span><br><span class="line">                <span class="keyword">if</span> (request.getQueryParams ().containsKey ( config.param ))&#123;</span><br><span class="line">                    List&lt;String&gt; strings = request.getQueryParams ( ).get ( config.param );</span><br><span class="line">                    <span class="keyword">for</span> (String string : strings) &#123;</span><br><span class="line">                        System.out.printf (<span class="string">&quot;------------局部过滤器--------%s = %s------&quot;</span>, config.param, string );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-自定义全局过滤器（不需要在配置文件中配置参数）"><a href="#4-自定义全局过滤器（不需要在配置文件中配置参数）" class="headerlink" title="4.自定义全局过滤器（不需要在配置文件中配置参数）"></a>4.自定义全局过滤器<font color=red>（不需要在配置文件中配置参数）</font></h4><p><strong>目标</strong>：定义一个全局过滤器检查请求中是否携带有token参数</p>
<p><strong>分析</strong>：</p>
<p>需求：编写全局过滤器，在过滤器中检查请求地址是否携带token参数。如果token参数的值存在则放行；如果token的参数值为空或者不存在则设置返回的状态码为：未授权也不再执行下去。</p>
<p>实现步骤：</p>
<ol>
<li>编写全局过滤器</li>
<li>测试</li>
</ol>
<p><strong>小结</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGlobalFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------全局过滤器MyGlobalFilter------------------&quot;</span>);</span><br><span class="line">        String token = exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(token))&#123;</span><br><span class="line">            <span class="comment">//设置响应状态码为未授权</span></span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//值越小越先执行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-Gateway其它配置说明"><a href="#6-Gateway其它配置说明" class="headerlink" title="6.Gateway其它配置说明"></a>6.Gateway其它配置说明</h3><p><strong>目标</strong>：Gateway网关的负载均衡和熔断参数配置</p>
<p><strong>小结</strong>：</p>
<p>网关服务配置文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">6000</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">2000</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="7-Gateway跨域配置（只发生在前端，一般是ajax）"><a href="#7-Gateway跨域配置（只发生在前端，一般是ajax）" class="headerlink" title="7.Gateway跨域配置（只发生在前端，一般是ajax）"></a>7.Gateway跨域配置<font color=red>（只发生在前端，一般是ajax）</font></h3><p>一般网关都是所有微服务的统一入口，必然在被调用的时候会出现跨域问题</p>
<p><strong>跨域：</strong>在js请求访问中，如果访问的地址与当前服务器的域名、ip或者端口号不一致则称为跨域请求。若不解决不<br>能获取到对应地址的返回结果</p>
<p>如：从在<a href="http://localhost:9090中的js访问">http://localhost:9090中的js访问</a> <a href="http://localhost:9000的数据，因为端口不同，所以也是跨域请求">http://localhost:9000的数据，因为端口不同，所以也是跨域请求</a></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-gateway</span></span><br><span class="line">  <span class="comment">#配置网关</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="comment">#跨域请求处理</span></span><br><span class="line">      <span class="attr">globalcors:</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="comment">#allowedOrigins: * # 这种写法或者下面的都可以，*表示全部</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://docs.spring.io&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">GET</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述配置表示：可以允许来自 <a href="http://docs.spring.io/">http://docs.spring.io</a> 的get请求方式获取服务数据。<br>allowedOrigins 指定允许访问的服务器地址，如：<a href="http://localhost:10000/">http://localhost:10000</a> 也是可以的。<br>‘[/**]’ 表示对所有访问到网关服务器的请求地址<br>官网具体说明：<a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.1.RELEASE/multi/multi__cors_configuration.html">点击跳转</a></p>
</blockquote>
<h3 id="8-总配置"><a href="#8-总配置" class="headerlink" title="8.总配置"></a>8.总配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-gateway</span></span><br><span class="line">  <span class="comment">#配置网关</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="comment">#id可以任意</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service-route</span></span><br><span class="line">        <span class="comment">#代理的服务地址</span></span><br><span class="line">          <span class="comment">#uri: http://127.0.0.1:9091</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://user-service</span> <span class="comment">#lb是LoadBalance（负载均衡）的简写</span></span><br><span class="line">        <span class="comment">#路由断言：可以匹配映射地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="comment">#- Path=/user/**</span></span><br><span class="line">            <span class="comment">#- Path=/**</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/api/user/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="comment"># 添加前期路径前缀（和Path结合）</span></span><br><span class="line">            <span class="comment">#- PrefixPath=/user #http://localhost:10010/2 -&gt; http://localhost:9091/user/2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 去除路径前缀，1表示去一个，2表示去两个，以此类推（和Path结合）</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=1</span> <span class="comment">#http://localhost:10010/api/user/2 -&gt; http://localhost:9091/user/2</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">MyParam=name</span> <span class="comment">#自定义的局部过滤器</span></span><br><span class="line">      <span class="comment">#默认过滤器，会对所有路由都生效</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddResponseHeader=X-Response-Foo,Bar</span> <span class="comment">#头名称和值可以自定义</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddResponseHeader=MyKey,Hello</span></span><br><span class="line">      <span class="comment">#跨域请求处理</span></span><br><span class="line">      <span class="attr">globalcors:</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="comment">#allowedOrigins: * # 这种写法或者下面的都可以，*表示全部</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://docs.spring.io&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">GET</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">6000</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">2000</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="9-Gateway的高可用（了解）"><a href="#9-Gateway的高可用（了解）" class="headerlink" title="9.Gateway的高可用（了解）"></a>9.Gateway的高可用（了解）</h3><p>启动多个Gateway服务，自动注册到Eureka，形成集群。如果是服务内部访问，访问Gateway，自动负载均衡，没问题。但是，Gateway更多是外部访问，PC端、移动端等。它们无法通过Eureka进行负载均衡，那么该怎么办？此时，可以使用其它的服务网关，来对Gateway进行代理。比如：<code>Nginx</code></p>
<h3 id="10-Gateway与Feign的区别"><a href="#10-Gateway与Feign的区别" class="headerlink" title="10.Gateway与Feign的区别"></a>10.Gateway与Feign的区别</h3><p>Gateway网关一般直接给终端请求使用；Feign一般用在微服务之间调用。</p>
<ul>
<li>Gateway 作为整个应用的流量入口，接收所有的请求，如PC、移动端等，并且将不同的请求转发至不同的处理微服务模块，其作用可视为nginx；大部分情况下用作权限鉴定、服务端流量控制</li>
<li>Feign 则是将当前微服务的部分服务接口暴露出来，并且主要用于各个微服务之间的服务调用</li>
</ul>
<h2 id="六、分布式配置中心Config"><a href="#六、分布式配置中心Config" class="headerlink" title="六、分布式配置中心Config"></a><font color=red>六、分布式配置中心Config</font></h2><h3 id="1-简介-5"><a href="#1-简介-5" class="headerlink" title="1.简介"></a>1.简介</h3><p>在分布式系统中，由于服务数量非常多，配置文件分散在不同的微服务项目中，管理不方便。为了方便配置文件集中管理，需要分布式配置中心组件。在Spring Cloud中，提供了Spring Cloud Config，它支持配置文件放在配置服务的本地，也支持放在远程Git仓库（GitHub、码云）</p>
<ul>
<li>使用Spring Cloud Config配置中心后的架构如下图：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201003003403139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpc2h1d2VuNzk4Ng==,size_16,color_FFFFFF,t_70#pic_center"></p>
<blockquote>
<p>spring cloud config作用：可以通过修改在git仓库中的配置文件实现其它所有微服务的配置文件的修改</p>
</blockquote>
<h3 id="2-搭建配置中心微服务"><a href="#2-搭建配置中心微服务" class="headerlink" title="2.搭建配置中心微服务"></a>2.搭建配置中心微服务</h3><h4 id="1-创建配置文件"><a href="#1-创建配置文件" class="headerlink" title="1.创建配置文件"></a>1.创建配置文件</h4><p>在新建的仓库中创建需要被统一配置管理的配置文件</p>
<p><strong>配置文件的命名方式：</strong><code>&#123;application&#125;-&#123;profile&#125;.yml </code>或 <code>&#123;application&#125;-&#123;profile&#125;.properties</code></p>
<ul>
<li>application为应用名称</li>
<li>profile用于区分开发环境，测试环境、生产环境等</li>
<li>如user-dev.yml，表示用户微服务开发环境下使用的配置文件</li>
</ul>
<h4 id="2-添加配置中心依赖"><a href="#2-添加配置中心依赖" class="headerlink" title="2.添加配置中心依赖"></a>2.添加配置中心依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-给启动类添加-EnableConfigServer"><a href="#3-给启动类添加-EnableConfigServer" class="headerlink" title="3. 给启动类添加@EnableConfigServer"></a>3. 给启动类添加<code>@EnableConfigServer</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span> <span class="comment">//开启配置服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-配置文件"><a href="#4-配置文件" class="headerlink" title="4.配置文件"></a>4.配置文件</h4><p> <a href="http://localhost:12000/user-dev.yml">http://localhost:12000/user-dev.yml</a> 可以获取到</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">12000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-server</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">      	<span class="comment">#配置Git远程仓库地址</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://gitee.com/keepli/my-config.git</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure>

<h4 id="5-获取配置中心配置"><a href="#5-获取配置中心配置" class="headerlink" title="5.获取配置中心配置"></a>5.获取配置中心配置</h4><p><strong>目标</strong>：改造用户微服务user-service，配置文件信息不再由微服务项目提供，而是从配置中心获取</p>
<p><strong>分析</strong>：</p>
<p>需求：将服务提供工程user-service的application.yml配置文件删除，修改为从配置中心config-server中获取</p>
<p>实现步骤：</p>
<ol>
<li>添加启动器依赖</li>
<li>修改配置文件</li>
<li>启动测试</li>
</ol>
<p><strong>小结</strong>：</p>
<p>将原来的application.yml删除；然后添加bootstrap.yml配置文件，该文件也是spring boot的默认配置文件，其内容经常配置一些项目中固定的配置项。如果是项目经常变动的应该配置到application.yml中，现在使用了配置中心则应该配置到git仓库中对于的配置文件</p>
<ul>
<li>依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>配置文件<code>bootstrap.yml</code><font color=red>（此文件名也是springboot支持的）</font></li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="comment"># 要与仓库中的配置文件的application保持一致</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">user</span></span><br><span class="line">      <span class="comment"># 要与仓库中的配置文件的profile保持一致</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span></span><br><span class="line">      <span class="comment"># 要与仓库中的配置文件所属的版本（分支）一样</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment"># 使用配置中心</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 配置中心服务名</span></span><br><span class="line">        <span class="attr">service-id:</span> <span class="string">config-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure>

<h2 id="七、Spring-Cloud-Bus"><a href="#七、Spring-Cloud-Bus" class="headerlink" title="七、Spring Cloud Bus"></a><font color=red>七、Spring Cloud Bus</font></h2><h3 id="1-简介-6"><a href="#1-简介-6" class="headerlink" title="1.简介"></a>1.简介</h3><p>Spring Cloud Bus是用轻量的消息代理将分布式的节点连接起来，可以用于广播配置文件的更改或者服务的监控管<br>理。也就是消息总线可以为微服务做监控，也可以实现应用程序之间相互通信。 Spring Cloud Bus可选的消息代理有RabbitMQ和Kafka</p>
<p>使用了Bus之后：</p>
<p><img src="https://img-blog.csdnimg.cn/20201003123913334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpc2h1d2VuNzk4Ng==,size_16,color_FFFFFF,t_70#pic_center"></p>
<blockquote>
<p>Spring Cloud Bus作用：将git仓库的配置文件更新，在不重启系统的情况下实现及时同步到各个微服务</p>
</blockquote>
<h3 id="2-应用-1"><a href="#2-应用-1" class="headerlink" title="2.应用"></a>2.应用</h3><p><strong>目标</strong>：启动RabbitMQ通过修改码云中的配置文件后发送Post请求实现及时更新用户微服务中的配置项</p>
<p><strong>分析</strong>：</p>
<p>需求：在码云的git仓库中修改user-dev.yml配置文件，实现不重启user-service的情况下可以及时更新配置文件。</p>
<p>实现步骤：</p>
<ol>
<li>启动RabbitMQ</li>
<li>修改配置中心config-server</li>
<li>修改服务提供工程user-service</li>
<li>测试</li>
</ol>
<p><strong>小结</strong>：</p>
<ul>
<li>config-server的依赖添加内容</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-bus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-stream-binder-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>config-server的配置文件添加内容</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">12000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-server</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="comment">#配置Git远程仓库地址</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://gitee.com/keepli/my-config.git</span></span><br><span class="line">  <span class="comment">#配置RabbitMQ信息</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">121.196</span><span class="number">.161</span><span class="number">.193</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="comment">#暴露触发消息总线的地址</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">bus-refresh</span></span><br></pre></td></tr></table></figure>

<ul>
<li>UserController的修改</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@RefreshScope</span> <span class="comment">//刷新配置（bus）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value( &quot;$&#123;test.name&#125;&quot; )</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span></span>&#123;</span><br><span class="line">        System.out.println (<span class="string">&quot;配置文件test.name为：&quot;</span>+name );</span><br><span class="line">        <span class="keyword">return</span> userService.findById ( id );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试：</strong></p>
<p>修改了配置内容后使用Postman或者RESTClient工具发送<font color=red>POST方式</font>请求访问地址<a href="http://127.0.0.1:12000/actuator/bus-refresh%E8%BF%9B%E8%A1%8C%E5%88%B7%E6%96%B0">http://127.0.0.1:12000/actuator/bus-refresh进行刷新</a></p>
<h2 id="八、Spring-Cloud-体系技术综合应用说明"><a href="#八、Spring-Cloud-体系技术综合应用说明" class="headerlink" title="八、Spring Cloud 体系技术综合应用说明"></a><font color=red>八、Spring Cloud 体系技术综合应用说明</font></h2><p>Spring Cloud中的Eureka、GateWay、Config、Bus、Feign等技术的综合应用</p>
<p><img src="https://img-blog.csdnimg.cn/20201004152823392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpc2h1d2VuNzk4Ng==,size_16,color_FFFFFF,t_70#pic_center"></p>
]]></content>
      <categories>
        <category>微服务架构</category>
      </categories>
      <tags>
        <tag>微服务架构</tag>
      </tags>
  </entry>
</search>
